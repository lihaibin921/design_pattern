# 设计模式学习记录
## 创建型
## 结构型
>处理**类**和**对象**的组合,以形成更大的结构
### 适配器模式
>**作用**:将一个接口转换成客户期望的另一个接口  
>**动机**:现有的类提供与需求相同或类似的功能, 但提供的接口不兼容, 又不能或不方便修改时  
>**特征**:增加一个新的类来解决接口不兼容  
>**场景**:别人的写的类你要用,第三方类等  
>**经验**:软件设计之初很少涉及适配器模式,一般出现在不断迭代过程中遇到相似需求时使用  
#### 适配器模式中的角色
>Target : 目标接口,客户需要的新接口  
>Adaptee : 适配者类,包含实现用户需求的的业务 , 但不够兼容  
>Adapter : 适配器类,对适配者进行调节,以提供用户需要的接口
#### 类适配器
>适配器模式通常分为类适配器和对象适配器  
>类适配器实现Target接口,继承Adaptee类  
>优点:作为适配者类的子类, 可以方便的置换父类方法
#### 对象适配器
>对象适配器实现Target接口,以组合方式引用Adaptee类  
>优点:可以适配多个适配者  
>类适配器与对象适配器只在引入Adaptee类上有区别, 因此产生了不同的优点
---
### 外观模式 (门面模式)
>**作用**:简化客户端与子系统的交互,是客户端与子系统解耦(封装交互,简化调用)   
>**场景**:子系统较复杂/客户端与多个子系统存在很大的依赖/层次化结构等  
>**经验**:外观模式是使用频率很高的一种对象结构型模式,(web开发中controller,service,dao三层架构是外观模式)
#### 外观模式中的角色
>Facade: 外观角色,可关联一个/多个子系统,客户端可调用它的方法,它将请求委派给对应的子系统处理  
>SubSysterm: 子系统角色,是类的集合,实现子系统的功能,可以直接被客户端/外观类调用,实际上外观类也是个客户端而已
#### 使用
>在子系统和客户端间增加外观角色,客户端只与外观对象交互,由外观对象调用相应子系统功能
#### 优缺点
>**优点**:减少客户端交互的对象数,简化客户端代码;客户端与子系统松耦合等  
>**缺点**:客户端对子系统细节知之甚少,减少了灵活性;子系统的修改可能导致外观类的修改
---
## 行为型